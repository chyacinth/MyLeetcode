/**
 * 难题。对于每个点，要找出*必须*删掉的初始基站。无脑做法，对每个点做dfs倒搜。聪明做法：从每个初始基站开始搜索，但是只有当从该基站可以不经过任何
 * 其他初始基站而到达某个点时才可以把这个基站加入某个点的"*必须*删掉的初始基站"列表。然后看看列表长度即可。注意这个必须！！
**/
class Solution {
public:
    void dfs(const int init, const int source, vector<vector<int>>& sources, 
             vector<vector<int>>& graph, vector<int>& record, const vector<char>& is_init) {
        for (int i = 0; i < graph.size(); ++i) {
            if (graph[init][i] == 1 && record[i] != source && sources[i].size() < 2 && !is_init[i]) {
                record[i] = source;
                sources[i].emplace_back(source);
                dfs(i, source, sources, graph, record, is_init);
            }
        }
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {        
        int n = graph.size();
        vector<char> is_init(n);
        for (auto source : initial) {
            is_init[source] = true;
        }
        vector<vector<int>> sources(n);
        vector<int> record(n, -1);
        vector<int> count(n);        
        for (auto source : initial) {
            ++count[source];
            if (sources[source].size() < 2) {
                record[source] = source;
                sources[source].emplace_back(source);
                dfs(source, source, sources, graph, record, is_init);
            }
        }        
        for (int i = 0; i < n; ++i) {            
            if (sources[i].size() == 1 && sources[i][0] != i) {
                ++count[sources[i][0]];                
            }
        }        
        int result = -1;
        int idx = 0;
        for (int i = 0; i < n; ++i) {           
            if (result < count[i]) {
                idx = i;
                result = count[i];
            }
        }
        return idx;
    }
};